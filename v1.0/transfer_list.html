<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>2. Transfer list &mdash; Firmware Handoff 1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=86f27845" />
      <link rel="stylesheet" type="text/css" href="_static/css/custom.css?v=aecbe2af" />

  
  
        <script src="_static/jquery.js?v=8dae8fb0"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=f2a433a1"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="3. Register usage at handoff boundary" href="register_conventions.html" />
    <link rel="prev" title="1. Introduction" href="introduction.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Firmware Handoff
          </a>
              <div class="version">
                1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">2. Transfer list</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#transfer-list-requirements">2.1. Transfer list requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="#transfer-list-header">2.2. Transfer list header</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tl-flags">2.2.1. TL Flags</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#tl-entry-header">2.3. TL entry header</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tl-contents">2.4. TL Contents</a></li>
<li class="toctree-l2"><a class="reference internal" href="#entry-type-allocation">2.5. Entry-type allocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#standard-operations">2.6. Standard operations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#validating-a-tl-header">2.6.1. Validating a TL header</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reading-a-tl">2.6.2. Reading a TL</a></li>
<li class="toctree-l3"><a class="reference internal" href="#adding-a-new-te">2.6.3. Adding a new TE</a></li>
<li class="toctree-l3"><a class="reference internal" href="#adding-a-new-te-with-special-data-alignment-requirement">2.6.4. Adding a new TE with special data alignment requirement</a></li>
<li class="toctree-l3"><a class="reference internal" href="#creating-a-tl">2.6.5. Creating a TL</a></li>
<li class="toctree-l3"><a class="reference internal" href="#relocating-a-tl">2.6.6. Relocating a TL</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#standard-transfer-entries">2.7. Standard transfer entries</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#empty-entry-layout-xferlist-void">2.7.1. Empty entry layout (XFERLIST_VOID)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fdt-entry-layout-xferlist-fdt">2.7.2. FDT entry layout (XFERLIST_FDT)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hob-block-entry-layout-xferlist-hob-b">2.7.3. HOB block entry layout (XFERLIST_HOB_B)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hob-list-entry-layout-xferlist-hob-l">2.7.4. HOB list entry layout (XFERLIST_HOB_L)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#acpi-table-aggregate-entry-layout-xferlist-acpi-aggr">2.7.5. ACPI table aggregate entry layout (XFERLIST_ACPI_AGGR)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tpm-event-log-table-entry-layout-xferlist-evlog">2.7.6. TPM event log table entry layout (XFERLIST_EVLOG)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tpm-crb-base-address-table-entry-layout-xferlist-tpm-crb-base">2.7.7. TPM CRB base address table entry layout (XFERLIST_TPM_CRB_BASE)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#entries-related-to-trusted-firmware">2.7.8. Entries related to Trusted Firmware</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="register_conventions.html">3. Register usage at handoff boundary</a></li>
<li class="toctree-l1"><a class="reference internal" href="references.html">4. References</a></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">5. Glossary</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Firmware Handoff</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active"><span class="section-number">2. </span>Transfer list</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/transfer_list.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="transfer-list">
<span id="sec-tl"></span><h1><span class="section-number">2. </span>Transfer list<a class="headerlink" href="#transfer-list" title="Link to this heading"></a></h1>
<p>The TL must have a TL header which must be followed by one or more Transfer
Entries (TE). The whole TL must be contiguous in physical address space. The TL
header and all the TEs are 8-byte aligned (we use <code class="code docutils literal notranslate"><span class="pre">align8()</span></code> to denote this).
The TL header specifies the number of bytes occupied by the
TL. The TEs are defined in <a class="reference internal" href="#sec-tl-entry-hdr"><span class="std std-numref">Section 2.3</span></a> and
<a class="reference internal" href="#sec-std-entries"><span class="std std-numref">Section 2.7</span></a>. Each TE carries a header which contains an
identifier, <code class="code docutils literal notranslate"><span class="pre">tag_id</span></code>, that must be used to determine the content of the associated
TE. The TL header is located at <code class="code docutils literal notranslate"><span class="pre">tl_base_pa</span></code>. The <code class="code docutils literal notranslate"><span class="pre">tl_base_pa</span></code> is passed in the
register allocated for that handoff boundary (as specified in
<a class="reference internal" href="register_conventions.html#handoff-arch-bindings"><span class="std std-numref">Section 3</span></a>). A
depiction of the TL is present in <a class="reference internal" href="#fig-list"><span class="std std-numref">Fig. 2</span></a> , there the first TE in
the list (TE[0]) is shown to start at the end of the TL header
(<code class="code docutils literal notranslate"><span class="pre">tl_base_pa</span> <span class="pre">+</span> <span class="pre">8</span></code>). The second TE in the list (TE[1]) starts at the next multiple
of 8, after the end of the TE[0].</p>
<figure class="align-default" id="id18">
<span id="fig-list"></span><a class="reference internal image-reference" href="_images/handoff_list_diagram.svg"><img alt="Transfer list example" height="498" src="_images/handoff_list_diagram.svg" width="627" /></a>
<figcaption>
<p><span class="caption-number">Fig. 2 </span><span class="caption-text">Transfer list example</span><a class="headerlink" href="#id18" title="Link to this image"></a></p>
</figcaption>
</figure>
<section id="transfer-list-requirements">
<h2><span class="section-number">2.1. </span>Transfer list requirements<a class="headerlink" href="#transfer-list-requirements" title="Link to this heading"></a></h2>
<p><strong>R1:</strong> The <code class="code docutils literal notranslate"><span class="pre">tl_base_pa</span></code> address must be non-zero and at an 8-byte aligned boundary.</p>
<p><strong>R2:</strong> All fields defined in this specification must be stored in memory with little-endian byte order.</p>
<p><strong>R3:</strong> The base address of a TE must be the 8-byte aligned address immediately after the end of the previous entry (or TL header, if the TE is the first entry on the TL).</p>
<p><strong>R4:</strong> When relocating the TL, the offset from <code class="code docutils literal notranslate"><span class="pre">tl_base_pa</span></code> to the nearest alignment boundary specified by the <code class="code docutils literal notranslate"><span class="pre">alignment</span></code> field in the TL header must be preserved.</p>
</section>
<section id="transfer-list-header">
<h2><span class="section-number">2.2. </span>Transfer list header<a class="headerlink" href="#transfer-list-header" title="Link to this heading"></a></h2>
<p>A TL must begin with a TL header. The layout of the TL header is shown in
<a class="reference internal" href="#tab-tl-header"><span class="std std-numref">Table 1</span></a>.  The presence of a TL header may be verified by
inspecting the signature field which must contain the <code class="code docutils literal notranslate"><span class="pre">0x4a0f_b10b</span></code> value.  The
version field determines the contents of the handoff start header. The version
will only be changed, by an update to this specification, when new TL header or
TE header fields are defined (i.e. not when allocating new tag IDs), and all
changes will be backwards-compatible to older readers.</p>
<span id="tab-tl-header"></span><table class="docutils align-default" id="id19">
<caption><span class="caption-number">Table 1 </span><span class="caption-text">TL header</span><a class="headerlink" href="#id19" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 13.3%" />
<col style="width: 13.3%" />
<col style="width: 13.3%" />
<col style="width: 60.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Size (bytes)</p></th>
<th class="head"><p>Offset (bytes)</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>signature</p></td>
<td><p>0x4</p></td>
<td><p>0x0</p></td>
<td><p>The value of signature must be <code class="code docutils literal notranslate"><span class="pre">0x4a0f_b10b</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>checksum</p></td>
<td><p>0x1</p></td>
<td><p>0x4</p></td>
<td><p>If enabled by the flags, the checksum is used to provide basic protection against something overwriting the TL in memory. The checksum is set to a value such that the xor over every byte in the {<code class="code docutils literal notranslate"><span class="pre">tl_base_pa</span></code>, …, <code class="code docutils literal notranslate"><span class="pre">tl_base_pa</span> <span class="pre">+</span> <span class="pre">used_size</span> <span class="pre">-</span> <span class="pre">1</span></code>} address range, is equal to <code class="code docutils literal notranslate"><span class="pre">0</span></code>. For the purposes of this calculation, the value of this checksum field in the TL header must be assumed as <code class="code docutils literal notranslate"><span class="pre">0</span></code>. Note that the checksum must include the TL header, all TEs and the inter-TE padding, but must not include the range reserved for future TE additions up to total_size. The values of inter-TE padding bytes are not defined by this specification and may be uninitialized memory. (This means that multiple TLs with exactly the same size and contents may still have different checksum values.). If checksums are not used, this must be <code class="code docutils literal notranslate"><span class="pre">0</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>version</p></td>
<td><p>0x1</p></td>
<td><p>0x5</p></td>
<td><p>The version of the TL header. This field must be set to <code class="code docutils literal notranslate"><span class="pre">0x1</span></code> for the TL header layout described in this version of the table. Code that encounters a TL with a version higher than it knows to support may still read the TL and all its TEs, and assume that it is backwards-compatible to previous versions (ignoring any extra bytes in a potentially larger TL or TE header). However, code may not append new entries to a TL unless it knows how to append entries for the specified version.</p></td>
</tr>
<tr class="row-odd"><td><p>hdr_size</p></td>
<td><p>0x1</p></td>
<td><p>0x6</p></td>
<td><p>The size of this TL header in bytes. This field is set to <code class="code docutils literal notranslate"><span class="pre">0x18</span></code> for the TL header layout described in this version of the table.</p></td>
</tr>
<tr class="row-even"><td><p>alignment</p></td>
<td><p>0x1</p></td>
<td><p>0x7</p></td>
<td><p>The maximum alignment required by any TE in the TL, specified as a power of two. For a newly created TL, the alignment requirement is <code class="code docutils literal notranslate"><span class="pre">8</span></code> so this value should be set to <code class="code docutils literal notranslate"><span class="pre">3</span></code>. It must be updated whenever a new TE is added with a larger requirement than the current value.</p></td>
</tr>
<tr class="row-odd"><td><p>used_size</p></td>
<td><p>0x4</p></td>
<td><p>0x8</p></td>
<td><p>The number of bytes within the TL that are used by TEs. This field accounts for the size of the TL header plus the size of all the entries contained in the TL. It must be a multiple of <code class="code docutils literal notranslate"><span class="pre">8</span></code> (i.e. it includes the inter-TE padding after the end of the last TE). This field must be updated when any entry is added to the TL.</p></td>
</tr>
<tr class="row-even"><td><p>total_size</p></td>
<td><p>0x4</p></td>
<td><p>0xc</p></td>
<td><p>The number of bytes occupied by the entire TL, including any spare space at the end, after <code class="code docutils literal notranslate"><span class="pre">used_size</span></code>. Any entry producer must check if there is sufficient space before adding an entry to the list. Firmware can resize and/or relocate the TL and update this field accordingly, provided that the TL requirements are respected. This field must be a multiple of <code class="code docutils literal notranslate"><span class="pre">8</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>flags</p></td>
<td><p>0x4</p></td>
<td><p>0x10</p></td>
<td><p>Flags word. See below for contents.</p></td>
</tr>
<tr class="row-even"><td><p>reserved</p></td>
<td><p>0x4</p></td>
<td><p>0x14</p></td>
<td><p>Reserved word. Must be set to <code class="code docutils literal notranslate"><span class="pre">0</span></code> or ignored.</p></td>
</tr>
</tbody>
</table>
<section id="tl-flags">
<h3><span class="section-number">2.2.1. </span>TL Flags<a class="headerlink" href="#tl-flags" title="Link to this heading"></a></h3>
<p>The TL flags word is intended to signal properties relating to the TL as a
whole. Future flag values may be added according to the rules of the <code class="code docutils literal notranslate"><span class="pre">version</span></code>
field.</p>
<table class="docutils align-default" id="id20">
<caption><span class="caption-number">Table 2 </span><span class="caption-text">Flags</span><a class="headerlink" href="#id20" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 16.7%" />
<col style="width: 16.7%" />
<col style="width: 66.7%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Bit</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>has_checksum</p></td>
<td><p>A value of <code class="code docutils literal notranslate"><span class="pre">1</span></code> (true) indicates that this TL uses checksums. The checksum
field must be valid at the point of handoff.</p></td>
</tr>
<tr class="row-odd"><td><p>31:1</p></td>
<td><p>unused</p></td>
<td><p>Reserved for future use. Must be <code class="code docutils literal notranslate"><span class="pre">0</span></code>.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="tl-entry-header">
<span id="sec-tl-entry-hdr"></span><h2><span class="section-number">2.3. </span>TL entry header<a class="headerlink" href="#tl-entry-header" title="Link to this heading"></a></h2>
<p>All TEs must start with an entry header followed by a data section.</p>
<p>Note: the size of an entry (hdr_size + data_size) is not mandatorily an 8-byte
multiple. When traversing the TL firmware must compute the next TE address following
R3.</p>
<p>For example, assume the current TE is <code class="code docutils literal notranslate"><span class="pre">te</span></code> and its address is <code class="code docutils literal notranslate"><span class="pre">te_base_addr</span></code>.  Using
C language notation, a derivation of the base address of the next TE
(next_base_addr) is the following:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">next_base_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">align8</span><span class="p">(</span><span class="n">te_base_addr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">te</span><span class="p">.</span><span class="n">hdr_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">te</span><span class="p">.</span><span class="n">data_size</span><span class="p">)</span>
</pre></div>
</div>
<p>The TE header is defined in <a class="reference internal" href="#tab-te-header"><span class="std std-numref">Table 3</span></a>.</p>
<span id="tab-te-header"></span><table class="docutils align-default" id="id21">
<caption><span class="caption-number">Table 3 </span><span class="caption-text">TE header</span><a class="headerlink" href="#id21" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 14.3%" />
<col style="width: 14.3%" />
<col style="width: 14.3%" />
<col style="width: 57.1%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Size (bytes)</p></th>
<th class="head"><p>Offset (bytes)</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>tag_id</p></td>
<td><p>0x3</p></td>
<td><p>0x0</p></td>
<td><p>The entry type identifier.</p></td>
</tr>
<tr class="row-odd"><td><p>hdr_size</p></td>
<td><p>0x1</p></td>
<td><p>0x3</p></td>
<td><p>The size of this entry header in bytes. This field must be set to <code class="code docutils literal notranslate"><span class="pre">8</span></code> for the TE header layout described in this version of the table.</p></td>
</tr>
<tr class="row-even"><td><p>data_size</p></td>
<td><p>0x4</p></td>
<td><p>0x4</p></td>
<td><p>The exact size of the data content in bytes, not including inter-TE padding. May be <code class="code docutils literal notranslate"><span class="pre">0</span></code>.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="tl-contents">
<h2><span class="section-number">2.4. </span>TL Contents<a class="headerlink" href="#tl-contents" title="Link to this heading"></a></h2>
<p>Tags are expected to have a simple layout (representable by a C structure) and
each tag should only represent data for a single logical concept. Data for
multiple distinct concepts should be split across different tags, even if
they’re always expected to appear together on the first platform adding the tag
(to encourage reusability in different situations). Alternatively, complex data
may be represented in a different kind of well-established handoff data
structure (e.g. FDT <a class="reference internal" href="references.html#dt" id="id1"><span>[DT]</span></a>, HOB <a class="reference internal" href="references.html#pi" id="id2"><span>[PI]</span></a>) that is inserted into the TL as a single
TE. Tag layouts (including the meaning of all
fields) are considered stable after being added to this specification and must
never be changed in a backwards-incompatible way. If a backwards-incompatible
change is desired, a new tag ID should be allocated for the new version of the
layout instead.</p>
<p>Tag layouts may be changed in a backwards-compatible manner by allowing new
valid values in existing fields (including reserved fields), as long as the
original layout definition clearly defined how unknown values in those fields
should be handled, and the rest of the TE would still be considered valid and
correct for older readers that consider the new values unknown. TE layouts may
also be expanded by adding new fields at the end, with the same restrictions.
TEs should not contain explicit version numbers and instead just use the
<code class="code docutils literal notranslate"><span class="pre">data_size</span></code> value to infer how many fields exist. TE layouts which have been
changed like this must clearly document which fields or valid values were added
at a later time, and in what order.</p>
<p>It is strongly recommended that entries of a given type are
unique in the TL. If firmware designs require multiple TE instances of a given
type, then that TE type definition should provide sufficient information for
the TE consumer to disambiguate between all TE instances. That information can
be, for example, a sub-type field or contained within a self-describing data
blob.</p>
<p>The TL must not hold pointers or addresses within its entries, which refer to
anything in the TL. These can make it difficult to relocate the TL. TL
relocation typically happens in later phases of the boot when there is more
memory available, which is needed for adding larger entries.</p>
<p>The TL may hold pointers or addresses which refer to regions outside the TL, if
this is necessary. For example, the MMIO address of a device may be included in
a TE. But in general, pointers and addresses should be avoided. Instead, the
data structure itself should generally be contained within the TL. This approach
provides the greatest flexibility for later boot stages to handle memory as they
wish, since relocating the TL is fairly simple and self-contained, without
needing to consider relocating other data structures strewn around the memory.</p>
<p>Where pointers or addresses are needed due to some project-specific restriction,
a separate TE should generally be created for that purpose, rather than mixing
pointers with other data. Of course there may be exceptions where two pointers
belong together, or there is a pointer and a size which belong together. In any
case, the PR should clearly document the need for these pointers.</p>
</section>
<section id="entry-type-allocation">
<h2><span class="section-number">2.5. </span>Entry-type allocation<a class="headerlink" href="#entry-type-allocation" title="Link to this heading"></a></h2>
<p>Tag IDs must be allocated in this specification before use. A new tag ID can be
allocated by submitting a pull request to this repository that adds a
description of the respective TE data layout to this specification. Tag IDs do
not have to be allocated in order. Submitters are encouraged to try to group
tag IDs together in logical clusters at 16 or 256-aligned boundaries (e.g. all
tags related to a particular chipset or to a particular firmware project could
use adjacent tag numbers), but there are no predefined ranges and no
reservations of tag ranges for specific use.</p>
<p>The <code class="code docutils literal notranslate"><span class="pre">{0xff_f000,</span> <span class="pre">...,</span> <span class="pre">0xff_ffff}</span></code> range is reserved for non-standardized use.
Anyone is free to use tags from that range for any custom TE layout without
adding their definitions to this specification first. The use of this range is
<em>strongly discouraged</em> for anything other than local experiments or code that
will only ever be used in closed-source components owned by the entity
controlling the entire final firmware image. In particular, a creator of a TE
that just contains platform-specific data or internal structures specific to
a single firmware implementation, should allocate a standardized tag for it
in this specification – using the non-standardized range is strongly
discouraged. Since standards often emerge organically, the goal is to
create unique tag IDs for everything just in case it turns out to be useful in
more applications than initially anticipated. Basically, whenever you’re
submitting code for a new TE layout to any public open-source project, that’s
probably a good indication that you should allocate a tag ID for it in this
specification.</p>
<span id="tab-tag-id-ranges"></span><table class="docutils align-default" id="id22">
<caption><span class="caption-number">Table 4 </span><span class="caption-text">Tag ID ranges</span><a class="headerlink" href="#id22" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 27.3%" />
<col style="width: 72.7%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>tag ID range</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0 – 0x7f_ffff</p></td>
<td><p>Standardized range. Any tag ID in this range must first be allocated in this specification before being used. The allocation of the tag ID requires the entry layout to be defined as well.</p></td>
</tr>
<tr class="row-odd"><td><p>0x80_0000 – 0xff_efff</p></td>
<td><p>Reserved. (Can later be used to extend standardized range if necessary.)</p></td>
</tr>
<tr class="row-even"><td><p>0xff_f000 – 0xff_ffff</p></td>
<td><p>Non-standardized range. Tag IDs in this range may be used without allocation in this specification. This range should not be used for anything other than local experimentation or closed-source components that are entirely under the control of a single platform firmware integrator. Tags in this range are not tracked in this repository and PRs to add tag defintions for this range will not be accepted.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="standard-operations">
<span id="sec-operations"></span><h2><span class="section-number">2.6. </span>Standard operations<a class="headerlink" href="#standard-operations" title="Link to this heading"></a></h2>
<p>This section describes the valid operations that may be performed on a TL in
more detail, in order to clarify how to use the various fields and to serve as a
guideline for implementation.</p>
<section id="validating-a-tl-header">
<h3><span class="section-number">2.6.1. </span>Validating a TL header<a class="headerlink" href="#validating-a-tl-header" title="Link to this heading"></a></h3>
<p>Inputs:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span></code>: Base address of the existing TL.</p></li>
</ul>
<ol class="arabic simple">
<li><p>Compare <code class="code docutils literal notranslate"><span class="pre">tl.signature</span></code> (<code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span> <span class="pre">+</span> <span class="pre">0x0</span></code>) to <code class="code docutils literal notranslate"><span class="pre">0x4a0f_b10b</span></code>. On a mismatch,
abort (this is not a valid TL).</p></li>
<li><p>Compare <code class="code docutils literal notranslate"><span class="pre">tl.version</span></code> (<code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span> <span class="pre">+</span> <span class="pre">0x5</span></code>) to the expected version
(currently <code class="code docutils literal notranslate"><span class="pre">0x1</span></code>). If there is an exact match, the TL is valid
for all operations outlined in this section. If <code class="code docutils literal notranslate"><span class="pre">tl.version</span></code> is larger, the
TL is valid for reading but must not be modified or relocated. If
<code class="code docutils literal notranslate"><span class="pre">tl.version</span></code> is smaller, either abort or switch to code designed to
interpret the respective previous version of this specification (note that
the version number <code class="code docutils literal notranslate"><span class="pre">0x0</span></code> is illegal and processing should always abort if it
is found).</p></li>
<li><p><em>(optional)</em> Check that <code class="code docutils literal notranslate"><span class="pre">tl.used_size</span></code> (<code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span> <span class="pre">+</span> <span class="pre">0x8</span></code>) is smaller or equal
to <code class="code docutils literal notranslate"><span class="pre">tl.total_size</span></code> (<code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span> <span class="pre">+</span> <span class="pre">0xc</span></code>), and that <code class="code docutils literal notranslate"><span class="pre">tl.total_size</span></code> is smaller or
equal to the size of the total area reserved for the TL (if known). If not,
abort (TL is corrupted).</p></li>
<li><p><em>(optional)</em> If <code class="code docutils literal notranslate"><span class="pre">has_checksum</span></code>, check that the xor of <code class="code docutils literal notranslate"><span class="pre">tl.used_size</span></code> bytes
starting at <code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span></code> is 0x0. If not, abort (TL is corrupted).</p></li>
</ol>
</section>
<section id="reading-a-tl">
<h3><span class="section-number">2.6.2. </span>Reading a TL<a class="headerlink" href="#reading-a-tl" title="Link to this heading"></a></h3>
<p>Inputs:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span></code>: Base address of the existing TL.</p></li>
</ul>
<ol class="arabic simple">
<li><p>Calculate <code class="code docutils literal notranslate"><span class="pre">te_base_addr</span></code> as <code class="code docutils literal notranslate"><span class="pre">align8(tl_base_addr</span> <span class="pre">+</span> <span class="pre">tl.hdr_size)</span></code>. (Do not
hardcode the value for <code class="code docutils literal notranslate"><span class="pre">tl.hdr_size</span></code>!)</p></li>
<li><p>While <code class="code docutils literal notranslate"><span class="pre">te_base_addr</span> <span class="pre">-</span> <span class="pre">tl_base_addr</span></code> is smaller or equal to <code class="code docutils literal notranslate"><span class="pre">tl.used_size</span></code>:</p>
<ol class="arabic simple">
<li><p><em>(optional)</em> Check that <code class="code docutils literal notranslate"><span class="pre">te_base_addr</span> <span class="pre">+</span> <span class="pre">te.hdr_size</span> <span class="pre">+</span> <span class="pre">te.data_size</span> <span class="pre">-</span> <span class="pre">tl_base_addr</span></code>
is smaller or equal to <code class="code docutils literal notranslate"><span class="pre">tl.used_size</span></code>, otherwise abort (the TL is corrupted).</p></li>
<li><p>If <code class="code docutils literal notranslate"><span class="pre">te.tag_id</span></code> (<code class="code docutils literal notranslate"><span class="pre">te_base_addr</span> <span class="pre">+</span> <span class="pre">0x0</span></code>) is a known tag, interpret the data
at <code class="code docutils literal notranslate"><span class="pre">te_base_addr</span> <span class="pre">+</span> <span class="pre">te.hdr_size</span></code> accordingly. (Do not hardcode the value
for <code class="code docutils literal notranslate"><span class="pre">te.hdr_size</span></code>, even for known tags!) Otherwise, ignore the tag and
proceed with the next step.</p></li>
<li><p>Add <code class="code docutils literal notranslate"><span class="pre">align8(te.hdr_size</span> <span class="pre">+</span> <span class="pre">te.data_size)</span></code> to <code class="code docutils literal notranslate"><span class="pre">te_base_addr</span></code>.</p></li>
</ol>
</li>
</ol>
</section>
<section id="adding-a-new-te">
<h3><span class="section-number">2.6.3. </span>Adding a new TE<a class="headerlink" href="#adding-a-new-te" title="Link to this heading"></a></h3>
<p>Inputs:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span></code>: Base address of the TL to add a TE to.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">new_tag_id</span></code>: ID number of the tag for the new TE.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">new_data_size</span></code>: Size in bytes of the data to be encapsulated in the TE.</p></li>
<li><p>[data]: Data to be copied into the TE or generated on the fly.</p></li>
</ul>
<ol class="arabic simple">
<li><p><em>(optional)</em> Follow the steps in <a class="reference internal" href="#reading-a-tl">Reading a TL</a> to look for a TE where
<code class="code docutils literal notranslate"><span class="pre">te.tag_id</span></code> is <code class="code docutils literal notranslate"><span class="pre">0x0</span></code> (XFERLIST_VOID) and <code class="code docutils literal notranslate"><span class="pre">te.data_size</span></code> is greater or equal
to <code class="code docutils literal notranslate"><span class="pre">new_data_size</span></code>. If found:</p>
<ol class="arabic simple">
<li><p>Remember <code class="code docutils literal notranslate"><span class="pre">te.data_size</span></code> as <code class="code docutils literal notranslate"><span class="pre">old_void_data_size</span></code>.</p></li>
<li><p>Use the <code class="code docutils literal notranslate"><span class="pre">te_base_addr</span></code> of this tag for the rest of the operation.</p></li>
<li><p>If <code class="code docutils literal notranslate"><span class="pre">has_checksum</span></code>, xor the <code class="code docutils literal notranslate"><span class="pre">align8(new_data_size</span> <span class="pre">+</span> <span class="pre">0x8)</span></code> bytes starting at
<code class="code docutils literal notranslate"><span class="pre">te_base_addr</span></code> with <code class="code docutils literal notranslate"><span class="pre">tl.checksum</span></code>.</p></li>
<li><p>Skip the next step (step 2) with all its substeps.</p></li>
</ol>
</li>
<li><p>Calculate <code class="code docutils literal notranslate"><span class="pre">te_base_addr</span></code> as <code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span> <span class="pre">+</span> <span class="pre">tl.used_size</span></code>.</p>
<ol class="arabic simple">
<li><p>If <code class="code docutils literal notranslate"><span class="pre">tl.total_size</span> <span class="pre">-</span> <span class="pre">tl.used_size</span></code> is smaller than <code class="code docutils literal notranslate"><span class="pre">align8(new_data_size</span> <span class="pre">+</span> <span class="pre">0x8)</span></code>,
abort (not enough room to add TE).</p></li>
<li><p>If <code class="code docutils literal notranslate"><span class="pre">has_checksum</span></code>, xor the 4 bytes from <code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span> <span class="pre">+</span> <span class="pre">0x8</span></code> with
<code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span> <span class="pre">+</span> <span class="pre">0xc</span></code> from <code class="code docutils literal notranslate"><span class="pre">tl.checksum</span></code>.</p></li>
<li><p>Add <code class="code docutils literal notranslate"><span class="pre">align8(new_data_size</span> <span class="pre">+</span> <span class="pre">0x8)</span></code> to <code class="code docutils literal notranslate"><span class="pre">tl.used_size</span></code>.</p></li>
<li><p>If <code class="code docutils literal notranslate"><span class="pre">has_checksum</span></code>, xor the 4 bytes from <code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span> <span class="pre">+</span> <span class="pre">0x8</span></code> to
<code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span> <span class="pre">+</span> <span class="pre">0xc</span></code> with <code class="code docutils literal notranslate"><span class="pre">tl.checksum</span></code>.</p></li>
</ol>
</li>
<li><p>Set <code class="code docutils literal notranslate"><span class="pre">te.tag_id</span></code> (<code class="code docutils literal notranslate"><span class="pre">te_base_addr</span> <span class="pre">+</span> <span class="pre">0x0</span></code>) to <code class="code docutils literal notranslate"><span class="pre">new_tag_id</span></code>.</p></li>
<li><p>Set <code class="code docutils literal notranslate"><span class="pre">te.hdr_size</span></code> (<code class="code docutils literal notranslate"><span class="pre">te_base_addr</span> <span class="pre">+</span> <span class="pre">0x3</span></code>) to <code class="code docutils literal notranslate"><span class="pre">8</span></code>.</p></li>
<li><p>Set <code class="code docutils literal notranslate"><span class="pre">te.data_size</span></code> (<code class="code docutils literal notranslate"><span class="pre">te_base_addr</span> <span class="pre">+</span> <span class="pre">0x4</span></code>) to <code class="code docutils literal notranslate"><span class="pre">new_data_size</span></code>.</p></li>
<li><p>Copy or generate the TE data into <code class="code docutils literal notranslate"><span class="pre">te_base_addr</span> <span class="pre">+</span> <span class="pre">0x8</span></code>.</p></li>
<li><p>If <code class="code docutils literal notranslate"><span class="pre">has_checksum</span></code>, xor the <code class="code docutils literal notranslate"><span class="pre">align8(new_data_size</span> <span class="pre">+</span> <span class="pre">0x8)</span></code> bytes starting at
<code class="code docutils literal notranslate"><span class="pre">te_base_addr</span></code> with <code class="code docutils literal notranslate"><span class="pre">tl.checksum</span></code>.</p></li>
<li><p>If an existing XFERLIST_VOID TE was chosen to be overwritten in step 1, and
<code class="code docutils literal notranslate"><span class="pre">old_void_data_size</span> <span class="pre">-</span> <span class="pre">new_data_size</span></code> is greater or equal to <code class="code docutils literal notranslate"><span class="pre">0x8</span></code>:</p>
<ol class="arabic simple">
<li><p>Use <code class="code docutils literal notranslate"><span class="pre">te_base_addr</span> <span class="pre">+</span> <span class="pre">align8(new_data_size</span> <span class="pre">+</span> <span class="pre">0x8)</span></code> as the new <code class="code docutils literal notranslate"><span class="pre">te_base_addr</span></code>
for a new XFERLIST_VOID tag.</p></li>
<li><p>If <code class="code docutils literal notranslate"><span class="pre">has_checksum</span></code>, xor the 8 bytes from <code class="code docutils literal notranslate"><span class="pre">te_base_addr</span></code> to
<code class="code docutils literal notranslate"><span class="pre">te_base_addr</span> <span class="pre">+</span> <span class="pre">0x8</span></code> with <code class="code docutils literal notranslate"><span class="pre">tl.checksum</span></code>.</p></li>
<li><p>Set <code class="code docutils literal notranslate"><span class="pre">te.tag_id</span></code> (<code class="code docutils literal notranslate"><span class="pre">te_base_addr</span> <span class="pre">+</span> <span class="pre">0x0</span></code>) to <code class="code docutils literal notranslate"><span class="pre">0x0</span></code> (XFERLIST_VOID).</p></li>
<li><p>Set <code class="code docutils literal notranslate"><span class="pre">te.hdr_size</span></code> (<code class="code docutils literal notranslate"><span class="pre">te_base_addr</span> <span class="pre">+</span> <span class="pre">0x3</span></code>) to <code class="code docutils literal notranslate"><span class="pre">0x8</span></code>.</p></li>
<li><p>Set <code class="code docutils literal notranslate"><span class="pre">te.data_size</span></code> (<code class="code docutils literal notranslate"><span class="pre">te_base_addr</span> <span class="pre">+</span> <span class="pre">0x4</span></code>) to
<code class="code docutils literal notranslate"><span class="pre">old_void_data_size</span> <span class="pre">-</span> <span class="pre">align8(new_data_size)</span> <span class="pre">-</span> <span class="pre">0x8</span></code>.</p></li>
<li><p>If <code class="code docutils literal notranslate"><span class="pre">has_checksum</span></code>, xor the 8 bytes from <code class="code docutils literal notranslate"><span class="pre">te_base_addr</span></code> to
<code class="code docutils literal notranslate"><span class="pre">te_base_addr</span> <span class="pre">+</span> <span class="pre">0x8</span></code> with <code class="code docutils literal notranslate"><span class="pre">tl.checksum</span></code>.</p></li>
</ol>
</li>
</ol>
</section>
<section id="adding-a-new-te-with-special-data-alignment-requirement">
<h3><span class="section-number">2.6.4. </span>Adding a new TE with special data alignment requirement<a class="headerlink" href="#adding-a-new-te-with-special-data-alignment-requirement" title="Link to this heading"></a></h3>
<p>Inputs:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span></code>: Base address of the TL to add a TE to.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">new_tag_id</span></code>: ID number of the tag for the new TE.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">new_alignment</span></code>: The alignment boundary as a power of <code class="code docutils literal notranslate"><span class="pre">2</span></code> that the data must be aligned to.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">new_data_size</span></code>: Size in bytes of the data to be encapsulated in the TE.</p></li>
<li><p>[data]: Data to be copied into the TE or generated on the fly.</p></li>
</ul>
<ol class="arabic simple">
<li><p>Calculate <code class="code docutils literal notranslate"><span class="pre">alignment_mask</span></code> as <code class="code docutils literal notranslate"><span class="pre">(1</span> <span class="pre">&lt;&lt;</span> <span class="pre">new_alignment)</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p></li>
<li><p>If <code class="code docutils literal notranslate"><span class="pre">(tl_base_addr</span> <span class="pre">+</span> <span class="pre">tl.used_size</span> <span class="pre">+</span> <span class="pre">0x8)</span> <span class="pre">&amp;</span> <span class="pre">alignment_mask</span></code> is not <code class="code docutils literal notranslate"><span class="pre">0x0</span></code>, follow the
steps in <a class="reference internal" href="#adding-a-new-te">Adding a new TE</a> with the following inputs (bypass the option to
overwrite an existing XFERLIST_VOID TE):</p>
<ol class="arabic simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span></code> remains the same</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">new_tag_id</span></code> is <code class="code docutils literal notranslate"><span class="pre">0x0</span></code> (XFERLIST_VOID)</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">new_data_size</span></code> is <code class="code docutils literal notranslate"><span class="pre">(1</span> <span class="pre">&lt;&lt;</span> <span class="pre">new_alignment)</span> <span class="pre">-</span> <span class="pre">((tl_base_addr</span> <span class="pre">+</span> <span class="pre">tl.used_size</span> <span class="pre">+</span> <span class="pre">0x8)</span> <span class="pre">&amp;</span> <span class="pre">alignment_mask)</span> <span class="pre">-</span> <span class="pre">0x8</span></code>.</p></li>
<li><p>No data (i.e. just don’t touch the bytes that form the data portion for this TE).</p></li>
</ol>
</li>
<li><p>Follow the steps in <a class="reference internal" href="#adding-a-new-te">Adding a new TE</a> with the original inputs (again bypass
the option to overwrite an existing XFERLIST_VOID TE).</p></li>
<li><p>If <code class="code docutils literal notranslate"><span class="pre">new_alignment</span></code> is larger than <code class="code docutils literal notranslate"><span class="pre">tl.alignment</span></code>:</p>
<ol class="arabic simple">
<li><p>If <code class="code docutils literal notranslate"><span class="pre">has_checksum</span></code>, xor <code class="code docutils literal notranslate"><span class="pre">tl.alignment</span></code> with <code class="code docutils literal notranslate"><span class="pre">tl.checksum</span></code>.</p></li>
<li><p>Set <code class="code docutils literal notranslate"><span class="pre">tl.alignment</span></code> to <code class="code docutils literal notranslate"><span class="pre">new_alignment</span></code>.</p></li>
<li><p>If <code class="code docutils literal notranslate"><span class="pre">has_checksum</span></code>, xor <code class="code docutils literal notranslate"><span class="pre">tl.alignment</span></code> with <code class="code docutils literal notranslate"><span class="pre">tl.checksum</span></code>.</p></li>
</ol>
</li>
</ol>
</section>
<section id="creating-a-tl">
<h3><span class="section-number">2.6.5. </span>Creating a TL<a class="headerlink" href="#creating-a-tl" title="Link to this heading"></a></h3>
<p>Inputs:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span></code>: Base address where to place the new TL.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">available_size</span></code>: Available size in bytes to reserve for the TL after <code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span></code>.</p></li>
</ul>
<ol class="arabic simple">
<li><p>Check that <code class="code docutils literal notranslate"><span class="pre">available_size</span></code> is larger than <code class="code docutils literal notranslate"><span class="pre">0x18</span></code> (the assumed <code class="code docutils literal notranslate"><span class="pre">tl.hdr_size</span></code>), otherwise abort.</p></li>
<li><p>Set <code class="code docutils literal notranslate"><span class="pre">tl.signature</span></code> (<code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span> <span class="pre">+</span> <span class="pre">0x0</span></code>) to <code class="code docutils literal notranslate"><span class="pre">0x4a0f_b10b</span></code>.</p></li>
<li><p>Set <code class="code docutils literal notranslate"><span class="pre">tl.checksum</span></code> (<code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span> <span class="pre">+</span> <span class="pre">0x4</span></code>) to <code class="code docutils literal notranslate"><span class="pre">0x0</span></code> (for now).</p></li>
<li><p>Set <code class="code docutils literal notranslate"><span class="pre">tl.version</span></code> (<code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span> <span class="pre">+</span> <span class="pre">0x5</span></code>) to <code class="code docutils literal notranslate"><span class="pre">0x1</span></code>.</p></li>
<li><p>Set <code class="code docutils literal notranslate"><span class="pre">tl.hdr_size</span></code> (<code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span> <span class="pre">+</span> <span class="pre">0x6</span></code>) to <code class="code docutils literal notranslate"><span class="pre">0x18</span></code>.</p></li>
<li><p>Set <code class="code docutils literal notranslate"><span class="pre">tl.alignment</span></code> (<code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span> <span class="pre">+</span> <span class="pre">0x7</span></code>) to <code class="code docutils literal notranslate"><span class="pre">0x3</span></code>.</p></li>
<li><p>Set <code class="code docutils literal notranslate"><span class="pre">tl.used_size</span></code> (<code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span> <span class="pre">+</span> <span class="pre">0x8</span></code>) to <code class="code docutils literal notranslate"><span class="pre">0x18</span></code> (the assumed <code class="code docutils literal notranslate"><span class="pre">tl.hdr_size</span></code>).</p></li>
<li><p>Set <code class="code docutils literal notranslate"><span class="pre">tl.total_size</span></code> (<code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span> <span class="pre">+</span> <span class="pre">0xc</span></code>) to <code class="code docutils literal notranslate"><span class="pre">available_size</span></code>.</p></li>
<li><p>If checksums are to be used, set <code class="code docutils literal notranslate"><span class="pre">tl.flags</span></code> (<code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span> <span class="pre">+</span> <span class="pre">0x10</span></code>) to <code class="code docutils literal notranslate"><span class="pre">1</span></code>,
else <code class="code docutils literal notranslate"><span class="pre">0</span></code>. This is the value of <code class="code docutils literal notranslate"><span class="pre">has_checksum</span></code>.</p></li>
<li><p>If <code class="code docutils literal notranslate"><span class="pre">has_checksum</span></code>, calculate the checksum as the xor of all bytes from
<code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span></code> to <code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span> <span class="pre">+</span> <span class="pre">tl.hdr_size</span></code>, and write the result to
<code class="code docutils literal notranslate"><span class="pre">tl.checksum</span></code>.</p></li>
</ol>
</section>
<section id="relocating-a-tl">
<h3><span class="section-number">2.6.6. </span>Relocating a TL<a class="headerlink" href="#relocating-a-tl" title="Link to this heading"></a></h3>
<p>Inputs:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span></code>: Base address of the existing TL.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">target_base</span></code>: Base address of the target region to relocate into.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">target_size</span></code>: Size in bytes of the target region to relocate into.</p></li>
</ul>
<ol class="arabic simple">
<li><p>Calculate <code class="code docutils literal notranslate"><span class="pre">alignment_mask</span></code> as <code class="code docutils literal notranslate"><span class="pre">(1</span> <span class="pre">&lt;&lt;</span> <span class="pre">tl.alignment)</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p></li>
<li><p>Calculate the current <code class="code docutils literal notranslate"><span class="pre">alignment_offset</span></code> as <code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span> <span class="pre">&amp;</span> <span class="pre">alignment_mask</span></code>.</p></li>
<li><p>Calculate <code class="code docutils literal notranslate"><span class="pre">new_tl_base</span></code> as <code class="code docutils literal notranslate"><span class="pre">(target_base</span> <span class="pre">&amp;</span> <span class="pre">~alignment_mask)</span> <span class="pre">+</span> <span class="pre">alignment_offset</span></code>.</p></li>
<li><p>If <code class="code docutils literal notranslate"><span class="pre">new_tl_base</span></code> is below <code class="code docutils literal notranslate"><span class="pre">target_base</span></code>, add <code class="code docutils literal notranslate"><span class="pre">alignment_mask</span> <span class="pre">+</span> <span class="pre">1</span></code> to <code class="code docutils literal notranslate"><span class="pre">new_tl_base</span></code>.</p></li>
<li><p>If <code class="code docutils literal notranslate"><span class="pre">new_tl_base</span> <span class="pre">-</span> <span class="pre">target_base</span> <span class="pre">+</span> <span class="pre">tl.used_size</span></code> is larger than <code class="code docutils literal notranslate"><span class="pre">target_size</span></code>, abort
(not enough space to relocate).</p></li>
<li><p>Copy <code class="code docutils literal notranslate"><span class="pre">tl.used_size</span></code> bytes from <code class="code docutils literal notranslate"><span class="pre">tl_base_addr</span></code> to <code class="code docutils literal notranslate"><span class="pre">new_tl_base</span></code>.</p></li>
<li><p>If <code class="code docutils literal notranslate"><span class="pre">has_checksum</span></code>, xor the the 4 bytes from <code class="code docutils literal notranslate"><span class="pre">new_tl_base</span> <span class="pre">+</span> <span class="pre">0xc</span></code>
to <code class="code docutils literal notranslate"><span class="pre">new_tl_base</span> <span class="pre">+</span> <span class="pre">0x10</span></code> with <code class="code docutils literal notranslate"><span class="pre">tl.checksum</span></code> (<code class="code docutils literal notranslate"><span class="pre">new_tl_base</span> <span class="pre">+</span> <span class="pre">0x4</span></code>).</p></li>
<li><p>Set <code class="code docutils literal notranslate"><span class="pre">tl.total_size</span></code> (<code class="code docutils literal notranslate"><span class="pre">new_tl_base</span> <span class="pre">+</span> <span class="pre">0xc</span></code>) to <code class="code docutils literal notranslate"><span class="pre">target_size</span> <span class="pre">-</span> <span class="pre">(new_tl_base</span> <span class="pre">-</span> <span class="pre">target_base)</span></code>.</p></li>
<li><p>If <code class="code docutils literal notranslate"><span class="pre">has_checksum</span></code>, xor the 4 bytes from <code class="code docutils literal notranslate"><span class="pre">new_tl_base</span> <span class="pre">+</span> <span class="pre">0xc</span></code> to
<code class="code docutils literal notranslate"><span class="pre">new_tl_base</span> <span class="pre">+</span> <span class="pre">0x10</span></code> with <code class="code docutils literal notranslate"><span class="pre">tl.checksum</span></code> (<code class="code docutils literal notranslate"><span class="pre">new_tl_base</span> <span class="pre">+</span> <span class="pre">0x4</span></code>).</p></li>
</ol>
</section>
</section>
<section id="standard-transfer-entries">
<span id="sec-std-entries"></span><h2><span class="section-number">2.7. </span>Standard transfer entries<a class="headerlink" href="#standard-transfer-entries" title="Link to this heading"></a></h2>
<p>The following entry types are currently defined:</p>
<ul class="simple">
<li><p>empty entry: tag_id = <code class="code docutils literal notranslate"><span class="pre">0</span></code>  (<a class="reference internal" href="#void-entry"><span class="std std-numref">Section 2.7.1</span></a>).</p></li>
<li><p>fdt entry: tag_id = <code class="code docutils literal notranslate"><span class="pre">1</span></code>  (<a class="reference internal" href="#fdt-entry"><span class="std std-numref">Section 2.7.2</span></a>).</p></li>
<li><p>single HOB block entry: tag_id = <code class="code docutils literal notranslate"><span class="pre">2</span></code> (<a class="reference internal" href="#hob-block-entry"><span class="std std-numref">Section 2.7.3</span></a>).</p></li>
<li><p>HOB list entry: tag_id = <code class="code docutils literal notranslate"><span class="pre">3</span></code> (<a class="reference internal" href="#hob-list-entry"><span class="std std-numref">Section 2.7.4</span></a>).</p></li>
<li><p>ACPI table aggregate entry: tag_id = <code class="code docutils literal notranslate"><span class="pre">4</span></code> (<a class="reference internal" href="#acpi-aggr-entry"><span class="std std-numref">Section 2.7.5</span></a>).</p></li>
<li><p>TPM event log entry: tag_id = <code class="code docutils literal notranslate"><span class="pre">5</span></code> (<a class="reference internal" href="#tpm-evlog-entry"><span class="std std-numref">Section 2.7.6</span></a>).</p></li>
<li><p>TPM CRB base entry: tag_id = <code class="code docutils literal notranslate"><span class="pre">6</span></code> (<a class="reference internal" href="#tpm-crb-base-entry"><span class="std std-numref">Section 2.7.7</span></a>).</p></li>
<li><p>Entries related to Trusted Firmware (<a class="reference internal" href="#tf-entries"><span class="std std-numref">Section 2.7.8</span></a>).</p></li>
</ul>
<section id="empty-entry-layout-xferlist-void">
<span id="void-entry"></span><h3><span class="section-number">2.7.1. </span>Empty entry layout (XFERLIST_VOID)<a class="headerlink" href="#empty-entry-layout-xferlist-void" title="Link to this heading"></a></h3>
<p>The empty or void entry should not contain any information to be consumed by any firmware stage.
The intent of the void entry type is to remove information from the list without needing to
relocate subsequent entries, or to create padding for entries that require a specific alignment.
Void entries may be freely overwritten with new TEs, provided the resulting TL remains valid
(i.e. a void entry can only be overwritten by a TE of equal or smaller size; if the size is more
than 8 bytes smaller, a new void entry must be created behind the new TE to cover the remaining
space up to the next TE).</p>
<span id="tab-void"></span><table class="docutils align-default" id="id23">
<caption><span class="caption-number">Table 5 </span><span class="caption-text">Empty type layout</span><a class="headerlink" href="#id23" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 14.3%" />
<col style="width: 14.3%" />
<col style="width: 14.3%" />
<col style="width: 57.1%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Size (bytes)</p></th>
<th class="head"><p>Offset (bytes)</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>tag_id</p></td>
<td><p>0x3</p></td>
<td><p>0x0</p></td>
<td><p>The tag_id field must be set to <code class="code docutils literal notranslate"><span class="pre">0</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>hdr_size</p></td>
<td><p>0x1</p></td>
<td><p>0x3</p></td>
<td><p>The size of this entry header in bytes must be set to <code class="code docutils literal notranslate"><span class="pre">8</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>data_size</p></td>
<td><p>0x4</p></td>
<td><p>0x4</p></td>
<td><p>The size of the void space in bytes. May be <code class="code docutils literal notranslate"><span class="pre">0</span></code>. For XFERLIST_VOID,
data_size <em>MUST</em> be a multiple of <code class="code docutils literal notranslate"><span class="pre">8</span></code> (i.e. there must be no space left to
inter-TE padding after this TE).</p></td>
</tr>
<tr class="row-odd"><td><p>void_data</p></td>
<td><p>data_size</p></td>
<td><p>hdr_size</p></td>
<td><p>Void content</p></td>
</tr>
</tbody>
</table>
</section>
<section id="fdt-entry-layout-xferlist-fdt">
<span id="fdt-entry"></span><h3><span class="section-number">2.7.2. </span>FDT entry layout (XFERLIST_FDT)<a class="headerlink" href="#fdt-entry-layout-xferlist-fdt" title="Link to this heading"></a></h3>
<p>The fdt is defined in <a class="reference internal" href="references.html#dt" id="id3"><span>[DT]</span></a>. The FDT TE contains the fdt in the data section.
The intent of the FDT entry is to carry the hardware description devicetree in
the flattened devicetree (FDT) <a class="reference internal" href="references.html#dt" id="id4"><span>[DT]</span></a> representation.</p>
<span id="tab-fdt"></span><table class="docutils align-default" id="id24">
<caption><span class="caption-number">Table 6 </span><span class="caption-text">FDT type layout</span><a class="headerlink" href="#id24" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 14.3%" />
<col style="width: 14.3%" />
<col style="width: 14.3%" />
<col style="width: 57.1%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Size (bytes)</p></th>
<th class="head"><p>Offset (bytes)</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>tag_id</p></td>
<td><p>0x3</p></td>
<td><p>0x0</p></td>
<td><p>The tag_id field must be set to <code class="code docutils literal notranslate"><span class="pre">1</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>hdr_size</p></td>
<td><p>0x1</p></td>
<td><p>0x3</p></td>
<td><p>The size of this entry header in bytes must be set to <code class="code docutils literal notranslate"><span class="pre">8</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>data_size</p></td>
<td><p>0x4</p></td>
<td><p>0x4</p></td>
<td><p>The size of the FDT in bytes.</p></td>
</tr>
<tr class="row-odd"><td><p>fdt</p></td>
<td><p>data_size</p></td>
<td><p>hdr_size</p></td>
<td><p>The fdt field contains the hardware description fdt.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="hob-block-entry-layout-xferlist-hob-b">
<span id="hob-block-entry"></span><h3><span class="section-number">2.7.3. </span>HOB block entry layout (XFERLIST_HOB_B)<a class="headerlink" href="#hob-block-entry-layout-xferlist-hob-b" title="Link to this heading"></a></h3>
<p>The HOB is defined in <a class="reference internal" href="references.html#pi" id="id5"><span>[PI]</span></a>. This entry type encapsulates a single HOB block.
The intent of the HOB block entry is to hold a single HOB block. A complete HOB
list can then be constructed, by a receiver, by obtaining all the HOB blocks in
the TL and following the HOB list requirements defined in <a class="reference internal" href="references.html#pi" id="id6"><span>[PI]</span></a>.</p>
<span id="tab-hob-block"></span><table class="docutils align-default" id="id25">
<caption><span class="caption-number">Table 7 </span><span class="caption-text">HOB block type layout</span><a class="headerlink" href="#id25" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 14.3%" />
<col style="width: 14.3%" />
<col style="width: 14.3%" />
<col style="width: 57.1%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Size (bytes)</p></th>
<th class="head"><p>Offset (bytes)</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>tag_id</p></td>
<td><p>0x3</p></td>
<td><p>0x0</p></td>
<td><p>The tag_id field must be set to <code class="code docutils literal notranslate"><span class="pre">2</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>hdr_size</p></td>
<td><p>0x1</p></td>
<td><p>0x3</p></td>
<td><p>The size of this entry header in bytes must be set to <code class="code docutils literal notranslate"><span class="pre">8</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>data_size</p></td>
<td><p>0x4</p></td>
<td><p>0x4</p></td>
<td><p>The size of the HOB block in bytes.</p></td>
</tr>
<tr class="row-odd"><td><p>hob_block</p></td>
<td><p>data_size</p></td>
<td><p>hdr_size</p></td>
<td><p>Holds a single HOB block.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="hob-list-entry-layout-xferlist-hob-l">
<span id="hob-list-entry"></span><h3><span class="section-number">2.7.4. </span>HOB list entry layout (XFERLIST_HOB_L)<a class="headerlink" href="#hob-list-entry-layout-xferlist-hob-l" title="Link to this heading"></a></h3>
<p>The HOB list is defined in <a class="reference internal" href="references.html#pi" id="id7"><span>[PI]</span></a>. The HOB list starts with a PHIT block and can
contain an arbitrary number of HOB blocks. This entry type encapsulates a
complete HOB list.  An enclosed HOB list must respect the HOB list constraints
specified in <a class="reference internal" href="references.html#pi" id="id8"><span>[PI]</span></a>.</p>
<span id="tab-hob-list"></span><table class="docutils align-default" id="id26">
<caption><span class="caption-number">Table 8 </span><span class="caption-text">HOB list type layout</span><a class="headerlink" href="#id26" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 14.3%" />
<col style="width: 14.3%" />
<col style="width: 14.3%" />
<col style="width: 57.1%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Size (bytes)</p></th>
<th class="head"><p>Offset (bytes)</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>tag_id</p></td>
<td><p>0x3</p></td>
<td><p>0x0</p></td>
<td><p>The tag_id field must be set to <code class="code docutils literal notranslate"><span class="pre">3</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>hdr_size</p></td>
<td><p>0x1</p></td>
<td><p>0x3</p></td>
<td><p>The size of this entry header in bytes must be set to <code class="code docutils literal notranslate"><span class="pre">8</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>data_size</p></td>
<td><p>0x4</p></td>
<td><p>0x4</p></td>
<td><p>The size of the HOB list in bytes.</p></td>
</tr>
<tr class="row-odd"><td><p>hob_list</p></td>
<td><p>data_size</p></td>
<td><p>hdr_size</p></td>
<td><p>Holds a complete HOB list.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="acpi-table-aggregate-entry-layout-xferlist-acpi-aggr">
<span id="acpi-aggr-entry"></span><h3><span class="section-number">2.7.5. </span>ACPI table aggregate entry layout (XFERLIST_ACPI_AGGR)<a class="headerlink" href="#acpi-table-aggregate-entry-layout-xferlist-acpi-aggr" title="Link to this heading"></a></h3>
<p>This entry type holds one or more ACPI tables. The first table must start at
offset <code class="code docutils literal notranslate"><span class="pre">hdr_size</span></code> from the start of the entry. Since ACPI tables usually have an
alignment requirement larger than 8, writers may first need to create an
XFERLIST_VOID padding entry so that the subsequent <code class="code docutils literal notranslate"><span class="pre">te_base_addr</span> <span class="pre">+</span> <span class="pre">te.hdr_size</span></code>
will be correctly aligned. Any subsequent ACPI tables must be located at the
next 16-byte alligned address following the preceding ACPI table. Note that each
ACPI table has a <code class="code docutils literal notranslate"><span class="pre">Length</span></code> field in the ACPI table header <a class="reference internal" href="references.html#acpi" id="id9"><span>[ACPI]</span></a>, which must be
used to determine the end of the ACPI table.  The <code class="code docutils literal notranslate"><span class="pre">data_size</span></code> value must be set
such that the last ACPI table in this entry ends at offset
<code class="code docutils literal notranslate"><span class="pre">hdr_size</span> <span class="pre">+</span> <span class="pre">data_size</span></code> from the start of the entry.</p>
<span id="tab-acpi-aggr"></span><table class="docutils align-default" id="id27">
<caption><span class="caption-number">Table 9 </span><span class="caption-text">ACPI table aggregate type layout</span><a class="headerlink" href="#id27" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 14.3%" />
<col style="width: 14.3%" />
<col style="width: 14.3%" />
<col style="width: 57.1%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Size (bytes)</p></th>
<th class="head"><p>Offset (bytes)</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>tag_id</p></td>
<td><p>0x3</p></td>
<td><p>0x0</p></td>
<td><p>The tag_id field must be set to <code class="code docutils literal notranslate"><span class="pre">4</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>hdr_size</p></td>
<td><p>0x1</p></td>
<td><p>0x3</p></td>
<td><p>The size of this entry header in bytes must be set to <code class="code docutils literal notranslate"><span class="pre">8</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>data_size</p></td>
<td><p>0x4</p></td>
<td><p>0x4</p></td>
<td><p>The size of all included ACPI tables + padding in bytes.</p></td>
</tr>
<tr class="row-odd"><td><p>acpi_tables</p></td>
<td><p>data_size</p></td>
<td><p>hdr_size</p></td>
<td><p>One or more ACPI tables.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="tpm-event-log-table-entry-layout-xferlist-evlog">
<span id="tpm-evlog-entry"></span><h3><span class="section-number">2.7.6. </span>TPM event log table entry layout (XFERLIST_EVLOG)<a class="headerlink" href="#tpm-event-log-table-entry-layout-xferlist-evlog" title="Link to this heading"></a></h3>
<p>This entry type holds TPM-related information for a platform. The TPM event log
info is a region containing a TPM event log as defined by TCG EFI Protocol
Specification <a class="reference internal" href="references.html#tcg-efi" id="id10"><span>[TCG_EFI]</span></a>.</p>
<span id="tab-tpm-evlog"></span><table class="docutils align-default" id="id28">
<caption><span class="caption-number">Table 10 </span><span class="caption-text">TPM event log type layout</span><a class="headerlink" href="#id28" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 12.5%" />
<col style="width: 12.5%" />
<col style="width: 25.0%" />
<col style="width: 50.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Size (bytes)</p></th>
<th class="head"><p>Offset (bytes)</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>tag_id</p></td>
<td><p>0x3</p></td>
<td><p>0x0</p></td>
<td><p>The tag_id field must be set to <code class="code docutils literal notranslate"><span class="pre">5</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>hdr_size</p></td>
<td><p>0x1</p></td>
<td><p>0x3</p></td>
<td><p>The size of this entry header in bytes must be set to <code class="code docutils literal notranslate"><span class="pre">8</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>data_size</p></td>
<td><p>0x4</p></td>
<td><p>0x4</p></td>
<td><p>The size of the event log in bytes + sizeof(flags) i.e. <code class="code docutils literal notranslate"><span class="pre">0x4</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>flags</p></td>
<td><p>0x4</p></td>
<td><p>hdr_size</p></td>
<td><p>flags are intended to signal properties of this TE. Bit 0 is
need_to_replay flag. Some firmware components may compute measurements
to be extended into a TPM and add them to the TPM event log, but those
components are unable  to access the TPM themselves. In this case, the
component should set the “need_to_replay” flag so that the next
component in the boot chain is aware that the PCRs have not been
extended. A component with access to the TPM would replay the event log
by reading each measurement recorded and extending it into the TPM. Once
the measurements are extended into the TPM, then the “need_to_replay”
flag must be cleared if the transfer list is passed to additional
firmware components. Default value is <code class="code docutils literal notranslate"><span class="pre">0</span></code>. Other bits should be set to
zero.</p></td>
</tr>
<tr class="row-even"><td><p>event_log</p></td>
<td><p>data_size - 0x4</p></td>
<td><p>hdr_size + 0x4</p></td>
<td><p>Holds a complete event log.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="tpm-crb-base-address-table-entry-layout-xferlist-tpm-crb-base">
<span id="tpm-crb-base-entry"></span><h3><span class="section-number">2.7.7. </span>TPM CRB base address table entry layout (XFERLIST_TPM_CRB_BASE)<a class="headerlink" href="#tpm-crb-base-address-table-entry-layout-xferlist-tpm-crb-base" title="Link to this heading"></a></h3>
<p>The CRB info defines the address of a region of memory that has been carved out
and reserved for use as a TPM Command Response Buffer interface.</p>
<span id="tab-tpm-crb-base"></span><table class="docutils align-default" id="id29">
<caption><span class="caption-number">Table 11 </span><span class="caption-text">TPM CRB base type layout</span><a class="headerlink" href="#id29" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 22.2%" />
<col style="width: 11.1%" />
<col style="width: 22.2%" />
<col style="width: 44.4%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Size (bytes)</p></th>
<th class="head"><p>Offset (bytes)</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>tag_id</p></td>
<td><p>0x3</p></td>
<td><p>0x0</p></td>
<td><p>The tag_id field must be set to <code class="code docutils literal notranslate"><span class="pre">6</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>hdr_size</p></td>
<td><p>0x1</p></td>
<td><p>0x3</p></td>
<td><p>The size of this entry header in bytes must be set to <code class="code docutils literal notranslate"><span class="pre">8</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>data_size</p></td>
<td><p>0x4</p></td>
<td><p>0x4</p></td>
<td><p>This value should be set to <code class="code docutils literal notranslate"><span class="pre">0xc`</span></code> i.e. <code class="code docutils literal notranslate"><span class="pre">sizeof(crb_base_address)</span> <span class="pre">+</span> <span class="pre">sizeof(crb_size)</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>crb_base_address</p></td>
<td><p>0x8</p></td>
<td><p>hdr_size</p></td>
<td><p>The physical base address of a region of memory reserved for use as a
TPM’s Command Response Buffer region.</p></td>
</tr>
<tr class="row-even"><td><p>crb_size</p></td>
<td><p>0x4</p></td>
<td><p>hdr_size + 0x8</p></td>
<td><p>Size of CRB.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="entries-related-to-trusted-firmware">
<span id="tf-entries"></span><h3><span class="section-number">2.7.8. </span>Entries related to Trusted Firmware<a class="headerlink" href="#entries-related-to-trusted-firmware" title="Link to this heading"></a></h3>
<p>The following entry types are defined for Trusted Firmware projects,
including TF-A, OP-TEE and Hafnium.</p>
<span id="tf-entries-summary"></span><table class="docutils align-default" id="id30">
<caption><span class="caption-number">Table 12 </span><span class="caption-text">Summary of Trusted Firmware Entries</span><a class="headerlink" href="#id30" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Tag ID</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#tab-optee-pageable-part-address"><span class="std std-ref">0x100</span></a></p></td>
<td><p>OP-TEE Pageable Part Address</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tab-dt-spmc-manifest"><span class="std std-ref">0x101</span></a></p></td>
<td><p>DT Formatted SPMC Manifest</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tab-entry-point-info"><span class="std std-ref">0x102</span></a></p></td>
<td><p>AArch64 Entry Point Info</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tab-ffa-sp-binary"><span class="std std-ref">0x103</span></a></p></td>
<td><p>FF-A SP Binary</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tab-rw-mem-layout"><span class="std std-ref">0x104</span></a></p></td>
<td><p>RW Memory Layout (64-bit)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tab-mbedtls-heap-info"><span class="std std-ref">0x105</span></a></p></td>
<td><p>Mbed-TLS Heap Info</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tab-dt-ffa-manifest"><span class="std std-ref">0x106</span></a></p></td>
<td><p>DT Formatted FF-A Manifest</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tab-rw-mem-layout32"><span class="std std-ref">0x107</span></a></p></td>
<td><p>RW Memory Layout (32-bit)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tab-entry-point-info32"><span class="std std-ref">0x108</span></a></p></td>
<td><p>AArch32 Entry Point Info</p></td>
</tr>
</tbody>
</table>
<p><strong>OP-TEE pageable part address entry layout (XFERLIST_OPTEE_PAGEABLE_PART_ADDR)</strong></p>
<p>This entry type holds the address of OP-TEE pageable part which is described in
<a class="reference internal" href="references.html#opteecore" id="id11"><span>[OPTEECore]</span></a>.
This address (of type ‘uint64_t’) is used when OPTEED (OP-TEE Dispatcher)
is the Secure Payload Dispatcher, indicating where to load the pageable image of
the OP-TEE OS.</p>
<span id="tab-optee-pageable-part-address"></span><table class="docutils align-default" id="id31">
<caption><span class="caption-number">Table 13 </span><span class="caption-text">OP-TEE pageable part address type layout</span><a class="headerlink" href="#id31" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 14.3%" />
<col style="width: 14.3%" />
<col style="width: 14.3%" />
<col style="width: 57.1%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Size (bytes)</p></th>
<th class="head"><p>Offset (bytes)</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>tag_id</p></td>
<td><p>0x3</p></td>
<td><p>0x0</p></td>
<td><p>The tag_id field must be set to <code class="code docutils literal notranslate"><span class="pre">0x100</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>hdr_size</p></td>
<td><p>0x1</p></td>
<td><p>0x3</p></td>
<td><p>The size of this entry header in bytes must be set to <code class="code docutils literal notranslate"><span class="pre">8</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>data_size</p></td>
<td><p>0x4</p></td>
<td><p>0x4</p></td>
<td><p>The size (in bytes) of the address of OP-TEE pageable part which must be set to <code class="code docutils literal notranslate"><span class="pre">8</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>pp_addr</p></td>
<td><p>0x8</p></td>
<td><p>hdr_size</p></td>
<td><p>Holds the address of OP-TEE pageable part</p></td>
</tr>
</tbody>
</table>
<p><strong>DT formatted SPMC manifest entry layout (XFERLIST_DT_SPMC_MANIFEST)</strong></p>
<p>This entry type holds the SPMC (Secure Partition Manager Core) manifest image
which is in DT format <a class="reference internal" href="references.html#dt" id="id12"><span>[DT]</span></a> and described in <a class="reference internal" href="references.html#spmcattr" id="id13"><span>[SPMCATTR]</span></a>.
This manifest contains the SPMC attribute node consumed by the SPMD
(Secure Partition Manager Dispatcher) at boot time.
It may also contain some information for the SPMC implementation, to
initialize itself.</p>
<span id="tab-dt-spmc-manifest"></span><table class="docutils align-default" id="id32">
<caption><span class="caption-number">Table 14 </span><span class="caption-text">DT formatted SPMC manifest type layout</span><a class="headerlink" href="#id32" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 14.3%" />
<col style="width: 14.3%" />
<col style="width: 14.3%" />
<col style="width: 57.1%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Size (bytes)</p></th>
<th class="head"><p>Offset (bytes)</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>tag_id</p></td>
<td><p>0x3</p></td>
<td><p>0x0</p></td>
<td><p>The tag_id field must be set to <code class="code docutils literal notranslate"><span class="pre">0x101</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>hdr_size</p></td>
<td><p>0x1</p></td>
<td><p>0x3</p></td>
<td><p>The size of this entry header in bytes must be set to <code class="code docutils literal notranslate"><span class="pre">8</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>data_size</p></td>
<td><p>0x4</p></td>
<td><p>0x4</p></td>
<td><p>The size of SPMC manifest in bytes.</p></td>
</tr>
<tr class="row-odd"><td><p>spmc_man</p></td>
<td><p>data_size</p></td>
<td><p>hdr_size</p></td>
<td><p>Holds a SPMC manifest image in DT format.</p></td>
</tr>
</tbody>
</table>
<p id="bit-ep-info"><strong>AArch64 executable entry point information (XFERLIST_EXEC_EP_INFO64)</strong></p>
<p>This entry type holds the AArch64 variant of <code class="code docutils literal notranslate"><span class="pre">entry_point_info</span></code>.
<code class="code docutils literal notranslate"><span class="pre">entry_point_info</span></code> is a TF-A-specific data structure <a class="reference internal" href="references.html#tf-bl31" id="id14"><span>[TF_BL31]</span></a> used to
represent the execution state of an image; that is, the state of general purpose
registers, PC, and SPSR.</p>
<p>This information is used by clients to setup the execution environment of
subsequent images. A concrete example is the execution of a bootloader such as
U-Boot in non-secure mode. In TF-A, the runtime firmware BL31 uses an
<code class="code docutils literal notranslate"><span class="pre">entry_point_info</span></code> structure corresponding to the bootloader, to setup the
general and special purpose registers. Following conventions
outlined in <a class="reference internal" href="register_conventions.html#aarch64-receiver"><span class="std std-ref">AArch64 Receiver</span></a>, the general purpose registers consumed
by the bootloader contain the base addresses of the device tree, and transfer
list; along with the transfer list signature.</p>
<p>In practice, control might be transferred from BL31 to any combination of
software running in Secure, Non-Secure, or Realm modes.</p>
<span id="tab-entry-point-info"></span><table class="docutils align-default" id="id33">
<caption><span class="caption-number">Table 15 </span><span class="caption-text">Entry point info type layout</span><a class="headerlink" href="#id33" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 13.3%" />
<col style="width: 33.3%" />
<col style="width: 13.3%" />
<col style="width: 40.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Size (bytes)</p></th>
<th class="head"><p>Offset (bytes)</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>tag_id</p></td>
<td><p>0x3</p></td>
<td><p>0x0</p></td>
<td><p>The tag_id field must be set to <code class="code docutils literal notranslate"><span class="pre">0x102</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>hdr_size</p></td>
<td><p>0x1</p></td>
<td><p>0x3</p></td>
<td><p>The size of this entry header in bytes must be set to <code class="code docutils literal notranslate"><span class="pre">8</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>data_size</p></td>
<td><p>0x4</p></td>
<td><p>0x4</p></td>
<td><p>Size of the <code class="code docutils literal notranslate"><span class="pre">entry_point_info</span></code> structure in bytes.</p></td>
</tr>
<tr class="row-odd"><td><p>ep_info_hdr</p></td>
<td><p>0x8</p></td>
<td><p>hdr_size</p></td>
<td><p>Header of type <a class="reference internal" href="#tab-param-header"><span class="std std-ref">param_header</span></a> containing
information about this structure. The type must be <code class="code docutils literal notranslate"><span class="pre">0x1</span></code>, version <code class="code docutils literal notranslate"><span class="pre">0x2</span></code>,
and size <code class="code docutils literal notranslate"><span class="pre">0x58</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>pc</p></td>
<td><p>0x8</p></td>
<td><p>hdr_size + 0x8</p></td>
<td><p>Program counter (entry point into image).</p></td>
</tr>
<tr class="row-odd"><td><p>spsr</p></td>
<td><p>0x4</p></td>
<td><p>hdr_size + 0x10</p></td>
<td><p>Saved Program Status Register.</p></td>
</tr>
<tr class="row-even"><td><p>x0</p></td>
<td><p>0x8</p></td>
<td><p>hdr_size + 0x18</p></td>
<td><p>Register X0.</p></td>
</tr>
<tr class="row-odd"><td><p>x1</p></td>
<td><p>0x8</p></td>
<td><p>hdr_size + 0x20</p></td>
<td><p>Register X1.</p></td>
</tr>
<tr class="row-even"><td><p>x2</p></td>
<td><p>0x8</p></td>
<td><p>hdr_size + 0x28</p></td>
<td><p>Register X2.</p></td>
</tr>
<tr class="row-odd"><td><p>x3</p></td>
<td><p>0x8</p></td>
<td><p>hdr_size + 0x30</p></td>
<td><p>Register X3.</p></td>
</tr>
<tr class="row-even"><td><p>x4</p></td>
<td><p>0x8</p></td>
<td><p>hdr_size + 0x38</p></td>
<td><p>Register X4.</p></td>
</tr>
<tr class="row-odd"><td><p>x5</p></td>
<td><p>0x8</p></td>
<td><p>hdr_size + 0x40</p></td>
<td><p>Register X5.</p></td>
</tr>
<tr class="row-even"><td><p>x6</p></td>
<td><p>0x8</p></td>
<td><p>hdr_size + 0x48</p></td>
<td><p>Register X6.</p></td>
</tr>
<tr class="row-odd"><td><p>x7</p></td>
<td><p>0x8</p></td>
<td><p>hdr_size + 0x50</p></td>
<td><p>Register X7.</p></td>
</tr>
</tbody>
</table>
<p>The structures header contains an attributes field which is used to encode the image’s
execution state (i.e., Secure, Non-Secure, or Realm).</p>
<span id="tab-param-header"></span><table class="docutils align-default" id="id34">
<caption><span class="caption-number">Table 16 </span><span class="caption-text">Layout of <code class="docutils literal notranslate"><span class="pre">param_header</span></code>.</span><a class="headerlink" href="#id34" title="Link to this table"></a></caption>
<tbody>
<tr class="row-odd"><td><p>Field</p></td>
<td><p>Size (bytes)</p></td>
<td><p>Offset (bytes)</p></td>
<td><p>Description</p></td>
</tr>
<tr class="row-even"><td><p>type</p></td>
<td><p>0x1</p></td>
<td><p>0x0</p></td>
<td><p>Type of the structure.</p></td>
</tr>
<tr class="row-odd"><td><p>version</p></td>
<td><p>0x1</p></td>
<td><p>0x1</p></td>
<td><p>Version of the structure.</p></td>
</tr>
<tr class="row-even"><td><p>size</p></td>
<td><p>0x2</p></td>
<td><p>0x2</p></td>
<td><p>Size of the structure in bytes.</p></td>
</tr>
<tr class="row-odd"><td><p>attr</p></td>
<td><p>0x4</p></td>
<td><p>0x4</p></td>
<td><p>Structure attributes.</p></td>
</tr>
</tbody>
</table>
<p><strong>FF-A SP binary (XFERLIST_FFA_SP_BINARY)</strong></p>
<p>This entry holds a reference to an FF-A Secure Partition (SP) binary.</p>
<p>This TE type is for an SPMC implementation to identify which entry
relates to the SP’s binary, such that it can install the binary and
hand-over execution.</p>
<span id="tab-ffa-sp-binary"></span><table class="docutils align-default" id="id35">
<caption><span class="caption-number">Table 17 </span><span class="caption-text">An FF-A SP binary type layout</span><a class="headerlink" href="#id35" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 14.3%" />
<col style="width: 14.3%" />
<col style="width: 14.3%" />
<col style="width: 57.1%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Size (bytes)</p></th>
<th class="head"><p>Offset (bytes)</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>tag_id</p></td>
<td><p>0x3</p></td>
<td><p>0x0</p></td>
<td><p>The tag_id field must be set to <code class="code docutils literal notranslate"><span class="pre">0x103</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>hdr_size</p></td>
<td><p>0x1</p></td>
<td><p>0x3</p></td>
<td><p>The size of this entry header in bytes must be set to <code class="code docutils literal notranslate"><span class="pre">8</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>data_size</p></td>
<td><p>0x4</p></td>
<td><p>0x4</p></td>
<td><p>The size of the SP binary in bytes.</p></td>
</tr>
<tr class="row-odd"><td><p>ffa_sp_binary</p></td>
<td><p>data_size</p></td>
<td><p>hdr_size</p></td>
<td><p>Holds the FF-A SP binary.</p></td>
</tr>
</tbody>
</table>
<p id="bit-mem-layout"><strong>Read-Write Memory Layout Entry Layout (XFERLIST_RW_MEM_LAYOUT64)</strong></p>
<p>This entry type holds a structure that describes the layout of a read-write
memory region.</p>
<p>For example, TF-A uses it to convey to BL2 the extent of memory it has available
to perform read-write operations on. BL2 maps the memory described by the layout
into its memory map during platform setup. If other memory types are required
(i.e. read-only memory) separate TE’s should be defined.</p>
<span id="tab-rw-mem-layout"></span><table class="docutils align-default" id="id36">
<caption><span class="caption-number">Table 18 </span><span class="caption-text">Layout for a RW memory layout entry</span><a class="headerlink" href="#id36" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 11.1%" />
<col style="width: 27.8%" />
<col style="width: 27.8%" />
<col style="width: 33.3%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Size (bytes)</p></th>
<th class="head"><p>Offset (bytes)</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>tag_id</p></td>
<td><p>0x3</p></td>
<td><p>0x0</p></td>
<td><p>The tag_id field must be set to <code class="code docutils literal notranslate"><span class="pre">0x104</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>hdr_size</p></td>
<td><p>0x1</p></td>
<td><p>0x3</p></td>
<td><p>The size of this entry header in bytes must be set to <code class="code docutils literal notranslate"><span class="pre">8</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>data_size</p></td>
<td><p>0x4</p></td>
<td><p>0x4</p></td>
<td><p>The size of the layout in bytes.</p></td>
</tr>
<tr class="row-odd"><td><p>addr</p></td>
<td><p>0x8</p></td>
<td><p>hdr_size</p></td>
<td><p>The base address of the memory region.</p></td>
</tr>
<tr class="row-even"><td><p>size</p></td>
<td><p>0x8</p></td>
<td><p>hdr_size + 0x8</p></td>
<td><p>The size of the memory region.</p></td>
</tr>
</tbody>
</table>
<p><strong>DT formatted FF-A manifest entry layout (XFERLIST_DT_FFA_MANIFEST)</strong></p>
<p>This entry type holds the FF-A manifest image whice is in DT format <a class="reference internal" href="references.html#dt" id="id15"><span>[DT]</span></a>,
as described in <a class="reference internal" href="references.html#tfaffamb" id="id16"><span>[TFAFFAMB]</span></a>.
This manifest contains the SP (Secure Partition) configuration, consumed
by the SPMC at boot time.</p>
<p>It may also contain some information to the SP itself.</p>
<span id="tab-dt-ffa-manifest"></span><table class="docutils align-default" id="id37">
<caption><span class="caption-number">Table 19 </span><span class="caption-text">DT formatted FF-A manifest type layout</span><a class="headerlink" href="#id37" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 14.3%" />
<col style="width: 14.3%" />
<col style="width: 14.3%" />
<col style="width: 57.1%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Size (bytes)</p></th>
<th class="head"><p>Offset (bytes)</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>tag_id</p></td>
<td><p>0x3</p></td>
<td><p>0x0</p></td>
<td><p>The tag_id field must be set to <code class="code docutils literal notranslate"><span class="pre">0x106</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>hdr_size</p></td>
<td><p>0x1</p></td>
<td><p>0x3</p></td>
<td><p>The size of this entry header in bytes must be set to <code class="code docutils literal notranslate"><span class="pre">8</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>data_size</p></td>
<td><p>0x4</p></td>
<td><p>0x4</p></td>
<td><p>The size of FF-A manifest in bytes.</p></td>
</tr>
<tr class="row-odd"><td><p>ffa_manifest</p></td>
<td><p>data_size</p></td>
<td><p>hdr_size</p></td>
<td><p>Holds a FF-A manifest image in DT format.</p></td>
</tr>
</tbody>
</table>
<p><strong>Mbed-TLS heap information (XFERLIST_MBEDTLS_HEAP_INFO)</strong></p>
<p>Specifies the location and size of a memory region, carved out for
stack-based memory allocation in Mbed-TLS. The buffer address and size are
passed to later stages for intialisation of Mbed-TLS.</p>
<span id="tab-mbedtls-heap-info"></span><table class="docutils align-default" id="id38">
<caption><span class="caption-number">Table 20 </span><span class="caption-text">Mbed-TLS heap info type layout</span><a class="headerlink" href="#id38" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 22.2%" />
<col style="width: 11.1%" />
<col style="width: 22.2%" />
<col style="width: 44.4%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Size (bytes)</p></th>
<th class="head"><p>Offset (bytes)</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>tag_id</p></td>
<td><p>0x3</p></td>
<td><p>0x0</p></td>
<td><p>The tag_id field must be set to <code class="code docutils literal notranslate"><span class="pre">0x105</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>hdr_size</p></td>
<td><p>0x1</p></td>
<td><p>0x3</p></td>
<td><p>The size of this entry header in bytes must be set to <code class="code docutils literal notranslate"><span class="pre">8</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>data_size</p></td>
<td><p>0x4</p></td>
<td><p>0x4</p></td>
<td><p>This value should be set to <code class="code docutils literal notranslate"><span class="pre">0x10`</span></code> i.e. <code class="code docutils literal notranslate"><span class="pre">sizeof(heap_address)</span> <span class="pre">+</span> <span class="pre">sizeof(heap_size)</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>heap_address</p></td>
<td><p>0x8</p></td>
<td><p>hdr_size</p></td>
<td><p>The address of memory to be used as the heap.</p></td>
</tr>
<tr class="row-even"><td><p>heap_size</p></td>
<td><p>0x8</p></td>
<td><p>hdr_size + 0x8</p></td>
<td><p>Size of memory region.</p></td>
</tr>
</tbody>
</table>
<p><strong>Read-Write Memory Layout Entry Layout (XFERLIST_RW_MEM_LAYOUT32)</strong></p>
<p>This entry type holds the 32-bit variant of
<a class="reference internal" href="#bit-mem-layout"><span class="std std-ref">XFERLIST_RW_MEM_LAYOUT64</span></a>. It is a structure used to
describe the layout of a read-write memory region. TF-A utilizes this entry type
to notify BL2 of the available memory for read-write operations. Note, for other
memory types, such as read-only memory, distinct entries should be created.</p>
<span id="tab-rw-mem-layout32"></span><table class="docutils align-default" id="id39">
<caption><span class="caption-number">Table 21 </span><span class="caption-text">Layout for a RW memory layout entry (32-bit variant)</span><a class="headerlink" href="#id39" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 11.1%" />
<col style="width: 27.8%" />
<col style="width: 27.8%" />
<col style="width: 33.3%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field</p></td>
<td><p>Size (bytes)</p></td>
<td><p>Offset (bytes)</p></td>
<td><p>Description</p></td>
</tr>
<tr class="row-even"><td><p>tag_id</p></td>
<td><p>0x3</p></td>
<td><p>0x0</p></td>
<td><p>The tag_id field must be set to <code class="code docutils literal notranslate"><span class="pre">0x107</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>hdr_size</p></td>
<td><p>0x1</p></td>
<td><p>0x3</p></td>
<td><p>The size of this entry header in bytes must be set to <code class="code docutils literal notranslate"><span class="pre">8</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>data_size</p></td>
<td><p>0x4</p></td>
<td><p>0x4</p></td>
<td><p>The size of the layout in bytes.</p></td>
</tr>
<tr class="row-odd"><td><p>addr</p></td>
<td><p>0x4</p></td>
<td><p>hdr_size</p></td>
<td><p>The 32-bit base address of the memory region.</p></td>
</tr>
<tr class="row-even"><td><p>size</p></td>
<td><p>0x4</p></td>
<td><p>hdr_size + 0x4</p></td>
<td><p>The size of the memory region.</p></td>
</tr>
</tbody>
</table>
<p><strong>AArch32 executable entry point information (XFERLIST_EXEC_EP_INFO32)</strong></p>
<p>This entry type holds the 32-bit variant of the <code class="code docutils literal notranslate"><span class="pre">entry_point_info</span></code>
structure.  <code class="code docutils literal notranslate"><span class="pre">entry_point_info</span></code> is a TF-A-specific data structure <a class="reference internal" href="references.html#tf-bl31" id="id17"><span>[TF_BL31]</span></a> used
to represent the execution state of an image; that is, the state of general
purpose registers, PC, and SPSR.</p>
<p>This information is used by clients to setup the execution environment of
subsequent images. It’s usage is identical to the 64-bit form represented by
<a class="reference internal" href="#bit-ep-info"><span class="std std-ref">XFERLIST_EXEC_EP_INFO64</span></a>.</p>
<span id="tab-entry-point-info32"></span><table class="docutils align-default" id="id40">
<caption><span class="caption-number">Table 22 </span><span class="caption-text">Entry point info type layout (32-bit variant)</span><a class="headerlink" href="#id40" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 14.3%" />
<col style="width: 21.4%" />
<col style="width: 21.4%" />
<col style="width: 42.9%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field</p></td>
<td><p>Size (bytes)</p></td>
<td><p>Offset (bytes)</p></td>
<td><p>Description</p></td>
</tr>
<tr class="row-even"><td><p>tag_id</p></td>
<td><p>0x3</p></td>
<td><p>0x0</p></td>
<td><p>The tag_id field must be set to <code class="code docutils literal notranslate"><span class="pre">0x108</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>hdr_size</p></td>
<td><p>0x1</p></td>
<td><p>0x3</p></td>
<td><p>The size of this entry header in bytes must be set to <code class="code docutils literal notranslate"><span class="pre">8</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>data_size</p></td>
<td><p>0x4</p></td>
<td><p>0x4</p></td>
<td><p>Size of the <code class="code docutils literal notranslate"><span class="pre">entry_point_info</span></code> structure in bytes.</p></td>
</tr>
<tr class="row-odd"><td><p>ep_info_hdr</p></td>
<td><p>0x8</p></td>
<td><p>hdr_size</p></td>
<td><p>Header of type <a class="reference internal" href="#tab-param-header"><span class="std std-ref">param_header</span></a> containing
information about this structure. The type must be <code class="code docutils literal notranslate"><span class="pre">0x1</span></code>, version <code class="code docutils literal notranslate"><span class="pre">0x2</span></code>,
and size <code class="code docutils literal notranslate"><span class="pre">0x24</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>pc</p></td>
<td><p>0x4</p></td>
<td><p>hdr_size + 0x8</p></td>
<td><p>Program counter (entry point into image).</p></td>
</tr>
<tr class="row-odd"><td><p>spsr</p></td>
<td><p>0x4</p></td>
<td><p>hdr_size + 0xc</p></td>
<td><p>Saved Program Status Register.</p></td>
</tr>
<tr class="row-even"><td><p>lr_svc</p></td>
<td><p>0x4</p></td>
<td><p>hdr_size + 0x10</p></td>
<td><p>Link register.</p></td>
</tr>
<tr class="row-odd"><td><p>r0</p></td>
<td><p>0x4</p></td>
<td><p>hdr_size + 0x14</p></td>
<td><p>Register R0.</p></td>
</tr>
<tr class="row-even"><td><p>r1</p></td>
<td><p>0x4</p></td>
<td><p>hdr_size + 0x18</p></td>
<td><p>Register R1.</p></td>
</tr>
<tr class="row-odd"><td><p>r2</p></td>
<td><p>0x4</p></td>
<td><p>hdr_size + 0x1c</p></td>
<td><p>Register R2.</p></td>
</tr>
<tr class="row-even"><td><p>r3</p></td>
<td><p>0x4</p></td>
<td><p>hdr_size + 0x20</p></td>
<td><p>Register R3.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="introduction.html" class="btn btn-neutral float-left" title="1. Introduction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="register_conventions.html" class="btn btn-neutral float-right" title="3. Register usage at handoff boundary" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022-2025, Firmware handoff contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
        <span class="fa fa-book"> Other Versions</span>
        v: v1.0
        <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
        <dl>
            <dt>Tags</dt>
            <dd><a href="../v0.9/transfer_list.html">v0.9</a></dd>
            <dd><a href="transfer_list.html">v1.0</a></dd>
        </dl>
        <dl>
            <dt>Branches</dt>
            <dd><a href="../main/transfer_list.html">main</a></dd>
        </dl>
    </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>